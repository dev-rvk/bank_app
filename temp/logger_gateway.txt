package logger

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"github.com/rs/zerolog"
	"github.com/rs/zerolog/log"
)

const (
	TimestampFormat = "2006-01-02T15:04:05.000Z07:00"
	InfoLevel       = "info"
	PanicLevel      = "panic"
	FatalLevel      = "fatal"
	ErrorLevel      = "error"
	WarnLevel       = "warn"
	DebugLevel      = "debug"
	TraceLevel      = "trace"
	BADKEY          = "!BADKEY"
)

const (
	timeFormat           = TimestampFormat
	defaultLogRetentions = 24
)

type Attribute struct {
	Value any
	Key   string
}

// Logger :
type Logger interface {
	Init()
	Panic(message string, attributes ...any)
	Fatal(message string, attributes ...any)
	Error(message string, err error, attributes ...any)
	Warn(message string, attributes ...any)
	WarnErr(message string, err error, attributes ...any)
	Info(message string, attributes ...any)
	Debug(message string, attributes ...any)
	DebugErr(message string, err error, attributes ...any)
	SetCallerSkip(skip int)
}

// LoggingService :
type LoggingService struct {
	// Level          string
	context        context.Context //nolint:containedctx
	file           *os.File
	Filename       string
	RotateDuration time.Duration
	CallerSkip     int
}

type LogOption struct {
	NodeID    string
	Module    string
	ReplicaID int
	ShardID   int
}

type LoggingServiceOptions struct {
	FilenamePrefix    string
	RetentionDuration time.Duration
}

func NewLogger(_ string, args ...LoggingServiceOptions) Logger {
	var rotateDuration time.Duration
	var fileName string

	if len(args) > 1 {
		if args[0].FilenamePrefix != "" {
			fileName = args[0].FilenamePrefix
		}

		if args[0].RetentionDuration > 0 {
			rotateDuration = args[0].RetentionDuration
		} else {
			rotateDuration = defaultLogRetentions * time.Hour
		}
	}

	logService := &LoggingService{
		Filename:       fileName,
		RotateDuration: rotateDuration,
		CallerSkip:     1,
	}
	logService.Init()
	ctx, err := logService.getCtx()
	if err != nil {
		panic(fmt.Errorf("fail to start Logger: %w", err))
	}
	logService.context = ctx

	return logService
}

func SetLogLevel(level string) {
	switch level {
	case PanicLevel:
		zerolog.SetGlobalLevel(zerolog.PanicLevel)
	case FatalLevel:
		zerolog.SetGlobalLevel(zerolog.FatalLevel)
	case ErrorLevel:
		zerolog.SetGlobalLevel(zerolog.ErrorLevel)
	case WarnLevel:
		zerolog.SetGlobalLevel(zerolog.WarnLevel)
	case InfoLevel:
		zerolog.SetGlobalLevel(zerolog.InfoLevel)
	case DebugLevel:
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	case TraceLevel:
		zerolog.SetGlobalLevel(zerolog.TraceLevel)
	default:
		zerolog.SetGlobalLevel(zerolog.DebugLevel)
	}
}

// Init :
func (loggingService *LoggingService) Init() {
	zerolog.TimeFieldFormat = timeFormat

	if loggingService.Filename != "" {
		if err := loggingService.openNew(); err != nil {
			return
		}
		if loggingService.RotateDuration != time.Duration(0) {
			runWatchdog(loggingService, loggingService.RotateDuration)
		}
		log.Logger = log.Output(zerolog.ConsoleWriter{
			Out:        loggingService.file,
			TimeFormat: time.RFC3339,
		})
	} else {
		log.Logger = log.Output(zerolog.ConsoleWriter{
			Out:        os.Stdout,
			TimeFormat: timeFormat,
		})
		loggingService.file = os.Stdout
		log.Logger = log.Output(zerolog.ConsoleWriter{
			Out:        os.Stdout,
			TimeFormat: timeFormat,
		})
	}
}

func (loggingService *LoggingService) SetCallerSkip(skip int) {
	loggingService.CallerSkip = skip
}

// Panic :
func (loggingService *LoggingService) Panic(message string, attributes ...any) {
	logObj := log.Panic().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack()
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

// Fatal :
func (loggingService *LoggingService) Fatal(message string, attributes ...any) {
	logObj := log.Fatal().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack()
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

func (loggingService *LoggingService) Error(message string, err error, attributes ...any) {
	logObj := log.Error().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack().Err(err)
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

// Warn :
func (loggingService *LoggingService) Warn(message string, attributes ...any) {
	logObj := log.Warn().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack()
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

func (loggingService *LoggingService) WarnErr(message string, err error, attributes ...any) {
	logObj := log.Warn().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack().Err(err)
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

// Info :
func (loggingService *LoggingService) Info(message string, attributes ...any) {
	logObj := log.Info().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack()
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

// Debug :
func (loggingService *LoggingService) Debug(message string, attributes ...any) {
	logObj := log.Debug().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack()
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

func (loggingService *LoggingService) DebugErr(message string, err error, attributes ...any) {
	logObj := log.Debug().Ctx(loggingService.context).Caller(loggingService.CallerSkip).Stack().Err(err)
	UpdateLogAttrs(logObj, attributes)
	logObj.Msg(message)
}

// Rotate :
func (loggingService *LoggingService) Rotate() error {
	return loggingService.openNew()
}

// openNew :
func (loggingService *LoggingService) openNew() (err error) {
	if loggingService.Filename != "" {
		newName := nextName(loggingService.Filename)
		// #nosec G304 -- file path is provided by system itself
		loggingService.file, err = os.OpenFile(newName, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
		return
	}
	loggingService.file = os.Stdout // default output

	return
}

// Close :
func (loggingService *LoggingService) Close() (err error) {
	err = fmt.Errorf("%w", loggingService.file.Close())
	return
}

// getCtx :
func (loggingService *LoggingService) getCtx() (context.Context, error) {
	if _, err := os.Stat(loggingService.file.Name()); err != nil {
		err := loggingService.openNew()
		if err != nil {
			return nil, err
		}
	}

	return zerolog.New(loggingService.file).With().Timestamp().
		CallerWithSkipFrameCount(3).
		Logger().
		WithContext(context.Background()), nil
}

// nextName : Generic function to get filename with timestamp
func nextName(name string) string {
	filename := name
	ext := filepath.Ext(filename)
	prefix := filename[:len(filename)-len(ext)]

	timestamp := time.Now().Format(TimestampFormat)

	return filepath.Join(fmt.Sprintf("%s-%s%s", prefix, timestamp, ext)) //nolint:gocritic
}

// watchdog : Structure which keeps track of duration after
type watchdog struct {
	interval time.Duration
}

// Run :
func (watchdog *watchdog) Run(l *LoggingService) {
	ticker := time.NewTicker(watchdog.interval)
	for range ticker.C {
		if err := l.Rotate(); err != nil {
			return
		}
	}
}

// runWatchdog :
func runWatchdog(loggingService *LoggingService, interval time.Duration) {
	wd := watchdog{interval: interval}
	go wd.Run(loggingService)
}

func UpdateLogAttrs(logEvent *zerolog.Event, attributes []any) {
	var attrObj Attribute
	for len(attributes) > 0 {
		attrObj, attributes = argsToAttr(attributes)
		logEvent.Any(attrObj.Key, attrObj.Value)
	}
}

func argsToAttr(args []interface{}) (attr Attribute, remainingAttrs []any) {
	if len(args) == 1 {
		return Attribute{Key: BADKEY, Value: args[0]}, nil
	}
	return Attribute{Key: args[0].(string), Value: args[1]}, args[2:]
}
